package com.own.thread;

public class Describe  {
    /* 1.多个线程start()的执行顺序不代表线程的启动顺序，原因：start方法通知“线程规划器”此线程已经准备就绪，等待调用线程的run方法*/
    /*2.使用stop暴力停止线程是极不安全的
        强制停止线程可能会使一些清理性工作得不到完成，另一种情况就是对锁定的对象进行了“解锁”
        导致数据得不到同步处理，出现数据不一致的问题*/
    /*3.线程在sleep状态下interupt线程，或先interupt线程后再sleep线程，会抛出异常*/
    /*4.使用suspend和resume，如果使用不当，极易造成公共的同步对象的独占，使其他线程无法访问
        公共同步对象*/
    /*5.yeild 方法放弃当前的CPU资源，但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片*/
    /*6.setDaemon设置成为守护线程，最后一个非守护线程结束时，守护线程才随着JVM一同结束工作*/
    /*7.当一个线程执行的代码出现异常时，其所持有的锁会自动释放*/
    /*8.一般情况下，synchronized代码块都不实用String作为锁对象，而是 new object 一个实例化对象*/
    /*9.每个锁对象都有两个队列，一个就绪队列，一个阻塞队列。一个线程被唤醒后，才会进入就绪队列，一个线程被wait后，进入阻塞队列*/
}
